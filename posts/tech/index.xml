<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>落魄山</title>
    <link>https://00001011b.github.io/posts/tech/</link>
    <description>Recent content on 落魄山</description>
    <image>
      <title>落魄山</title>
      <url>https://00001011b.github.io/images/author.jpg</url>
      <link>https://00001011b.github.io/images/author.jpg</link>
    </image>
    <generator>Hugo -- 0.144.1</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 27 Jun 2023 00:43:51 +0800</lastBuildDate>
    <atom:link href="https://00001011b.github.io/posts/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于 struct 声明中 self Referential 的说明</title>
      <link>https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Tue, 27 Jun 2023 00:43:51 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;https://book.douban.com/subject/1882483/&#34;&gt;《The C programming language, second edition》&lt;/a&gt;的 section A8.3 中，有这么一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于 C 语言里的 specifier 和 qualifier</title>
      <link>https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84specifier%E5%92%8Cqualifier/</link>
      <pubDate>Mon, 26 Jun 2023 23:39:45 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84specifier%E5%92%8Cqualifier/</guid>
      <description>&lt;p&gt;在C编程中，“specifier”（指示符）和“qualifier”（限定符）是两个具有不同含义的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指示符（Specifier）：在C编程中，指示符是用于定义变量或函数的类型和存储类的关键字。指示符包括&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;void&lt;/code&gt;、&lt;code&gt;extern&lt;/code&gt;、&lt;code&gt;static&lt;/code&gt;等。指示符用于指定变量或函数的基本属性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>从 ANSI Standart 的角度，解释 const 和 volatile 的区别</title>
      <link>https://00001011b.github.io/posts/tech/%E4%BB%8Eansi-standart%E7%9A%84%E8%A7%92%E5%BA%A6%E8%A7%A3%E9%87%8Aconst%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 18 Jun 2023 14:34:33 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E4%BB%8Eansi-standart%E7%9A%84%E8%A7%92%E5%BA%A6%E8%A7%A3%E9%87%8Aconst%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;当我阅读&lt;a href=&#34;https://book.douban.com/subject/1882483/&#34;&gt;《The C programming language, second edition》&lt;/a&gt; SECTION A8.2 (page 211) 时看到下面一段话，谈论的是 const 与 volatile 的对象与编译器优化相关的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt; properties are new with the ANSI Standart. The purpose of &lt;code&gt;const&lt;/code&gt; is to announce objects that may be placed in read-only memory, and perhaps to increase opportunities for optimization. The purpose of &lt;code&gt;volatile&lt;/code&gt; is to force an implementation to suppress optimization that could otherwise occur. For example, for a machine with memory-mapped input/output, a pointer to a device register might be declared as a pointer to &lt;code&gt;volatile&lt;/code&gt;, in order to prevent the compiler from removing apparently redundant references through the pointer. Except that it should diagnose explicit attempts to change const objects, a compiler compiler may ignore these qulifiers.&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解和区分 C 语言的 structure 和 union</title>
      <link>https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%86c%E8%AF%AD%E8%A8%80%E7%9A%84structure%E5%92%8Cunion/</link>
      <pubDate>Sat, 17 Jun 2023 00:04:46 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%86c%E8%AF%AD%E8%A8%80%E7%9A%84structure%E5%92%8Cunion/</guid>
      <description>&lt;p&gt;在C语言中，structure（结构体）和union（联合体）是用于组织和存储不同类型数据的方式。它们有相似之处，但也有一些关键的区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Structure（结构体）&lt;/strong&gt;：
结构体是一种用户自定义的数据类型，可以将不同类型的变量组合在一起形成一个逻辑上相关的数据单元。结构体的成员可以是不同的数据类型，每个成员都有自己的名称和内存地址。结构体的各个成员在内存中是按照定义的顺序存储的，每个成员占据自己的内存空间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>从底层逻辑去理解 C 语言的枚举类型</title>
      <link>https://00001011b.github.io/posts/tech/%E4%BB%8E%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E5%8E%BB%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 12 Jun 2023 22:51:40 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E4%BB%8E%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E5%8E%BB%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;快速知道枚举&#34;&gt;快速知道枚举&lt;/h3&gt;
&lt;p&gt;在C语言中，枚举（enumeration）是一种用户自定义的数据类型，用于定义一组具有离散取值的常量。枚举类型可以帮助程序员提高代码可读性和可维护性，因为它们允许使用有意义的标识符来表示一组相关的常量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解 C 语言变量</title>
      <link>https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 11 Jun 2023 14:03:41 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。&lt;/p&gt;
&lt;h3 id=&#34;1标识符&#34;&gt;1、标识符&lt;/h3&gt;
&lt;p&gt;标识符，本质上来讲，就是一个名字。通过这个名字，我们可以引用到（refers to） C 语言里的很多东西：&lt;/p&gt;</description>
    </item>
    <item>
      <title>物理定律的内涵与外延</title>
      <link>https://00001011b.github.io/posts/tech/%E7%89%A9%E7%90%86%E5%AE%9A%E5%BE%8B%E7%9A%84%E5%86%85%E6%B6%B5%E4%B8%8E%E5%A4%96%E5%BB%B6/</link>
      <pubDate>Thu, 24 Nov 2022 08:39:15 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E7%89%A9%E7%90%86%E5%AE%9A%E5%BE%8B%E7%9A%84%E5%86%85%E6%B6%B5%E4%B8%8E%E5%A4%96%E5%BB%B6/</guid>
      <description>&lt;p&gt;学习物理的时候，应试教育将我我们的视野及思维牢牢钉死在物理公式上。事实上，物理定律是具备本身的内涵与外延的，如果不懂/不知道这些，学习物理定律，就是邯郸学步罢了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Excel 计算周岁</title>
      <link>https://00001011b.github.io/posts/tech/excel%E8%AE%A1%E7%AE%97%E5%91%A8%E5%B2%81/</link>
      <pubDate>Tue, 13 Sep 2022 11:14:58 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/excel%E8%AE%A1%E7%AE%97%E5%91%A8%E5%B2%81/</guid>
      <description>&lt;p&gt;计算周岁时，并不是简单地用当前年份减去出生年份，而是要考虑到年、月和日三方面的因素。也就是很多人说的，生日还没到，还没满18岁。😁&lt;/p&gt;
&lt;h3 id=&#34;日期格式&#34;&gt;日期格式&lt;/h3&gt;
&lt;p&gt;因为我们的生日是用日期表示，因此在计算周岁之前，我们还要从 Excel 的角度去认识何为日期。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hugo 的安装，使用，及恢复</title>
      <link>https://00001011b.github.io/posts/tech/hugo%E5%AE%89%E8%A3%85%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Fri, 19 Aug 2022 13:21:53 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/hugo%E5%AE%89%E8%A3%85%E7%BB%B4%E6%8A%A4%E5%8F%8A%E6%81%A2%E5%A4%8D/</guid>
      <description>&lt;p&gt;如题，本文分成三个部分来撰写。以下全文基于 Ubuntu 18.05 编写。&lt;/p&gt;
&lt;h3 id=&#34;一安装&#34;&gt;一、安装&lt;/h3&gt;
&lt;p&gt;因为 hugo 依赖于 golang，因此，在安装 hugo 之前，先要安装 golang。以下是安装 golang 的步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href=&#34;https://go.dev/doc/install&#34;&gt;官网&lt;/a&gt;下载对应的 go 版本。&lt;/li&gt;
&lt;li&gt;删除电脑中以前的版本以及将第一步下载的 tar 包解压出来。放到&lt;code&gt;/usr/local/&lt;/code&gt;路径下。(请注意tar包的文件名)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ rm -rf /usr/local/go &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将&lt;code&gt;/usr/local/go/bin&lt;/code&gt;添加到系统路径下。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$PATH&lt;/span&gt;:/usr/local/go/bin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;检查是否安装成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ go version
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go version go1.19 linux/amd64
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;至此，我们可以从源码来安装我们的 hugo了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>说说模式规划</title>
      <link>https://00001011b.github.io/posts/tech/%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 27 May 2022 07:45:46 +0800</pubDate>
      <guid>https://00001011b.github.io/posts/tech/%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%92/</guid>
      <description>&lt;p&gt;说说模式的主要目的是取代 qq 空间、朋友圈、微博、微信。&lt;/p&gt;
&lt;p&gt;在 BluePrint 阶段，由于“说说本身的简短性”，我一直在思考是将所有说说放在同一个文件夹里，按年来分，还是每条说说独立在各自的文件夹中呢？&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
