<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何理解同步阻塞通信 | 落魄山</title><meta name=keywords content="channel"><meta name=description content="在 CSP（Communicating Sequential Processes）模型中，同步阻塞通信是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义："><meta name=author content="陈十一"><link rel=canonical href=https://00001011b.github.io/posts/tech/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.7fbafcc7cb487028a5ada65e367cc40eca3d02543d023dfc4bcaca04741b9f7e.css integrity="sha256-f7r8x8tIcCilraZeNnzEDso9AlQ9Aj38S8rKBHQbn34=" rel="preload stylesheet" as=style><link rel=icon href=https://00001011b.github.io/images/author.jpg><link rel=icon type=image/png sizes=16x16 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://00001011b.github.io/posts/tech/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://00001011b.github.io/posts/tech/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="落魄山"><meta property="og:title" content="如何理解同步阻塞通信"><meta property="og:description" content="在 CSP（Communicating Sequential Processes）模型中，同步阻塞通信是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-24T23:41:15+08:00"><meta property="article:modified_time" content="2025-06-24T23:41:15+08:00"><meta property="article:tag" content="Channel"><meta property="og:image" content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:title content="如何理解同步阻塞通信"><meta name=twitter:description content="在 CSP（Communicating Sequential Processes）模型中，同步阻塞通信是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://00001011b.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://00001011b.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"如何理解同步阻塞通信","item":"https://00001011b.github.io/posts/tech/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何理解同步阻塞通信","name":"如何理解同步阻塞通信","description":"在 CSP（Communicating Sequential Processes）模型中，同步阻塞通信是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义：\n","keywords":["channel"],"articleBody":"在 CSP（Communicating Sequential Processes）模型中，同步阻塞通信是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义：\n一、同步阻塞的本质：原子性握手 1. 通信的即时性 定义：发送方（Sender）和接收方（Receiver）必须同时处于“就绪状态”（即同时调用发送和接收操作），才能完成一次数据传递。 类比：类似打电话——双方必须同时拿起电话才能通话；若一方未接听，另一方会持续等待（阻塞）。 2. 数据传递的原子性 零中间状态：数据直接从发送方内存复制到接收方内存，中间不经过任何缓冲区。 无竞态风险：由于通信是瞬时完成的，不存在“发送一半数据”或“部分写入”的中间状态，天然避免数据不一致问题。 3. 时序强制同步 因果关系绑定：发送操作 P!data 和接收操作 Q?x 必须成对出现，且逻辑上视为同一时间点发生的事件。 语义等价：从外部观察者视角，发送和接收是同时完成的，类似于量子纠缠态的坍缩。 二、同步阻塞的底层实现 1. 无缓冲通道的阻塞行为（以 Go 为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ch := make(chan int) // 无缓冲通道 // 发送方协程 go func() { data := 42 ch \u003c- data // 阻塞，直到接收方就绪 fmt.Println(\"Sent\") // 发送完成后执行 }() // 接收方协程 go func() { result := \u003c-ch // 阻塞，直到发送方就绪 fmt.Println(\"Received:\", result) }() 运行时行为：若发送方先执行 ch \u003c- data，其协程会被挂起，加入通道的 sendq 等待队列；接收方就绪后，调度器唤醒双方并直接拷贝数据。 2. 同步的代价与收益 代价：可能导致协程阻塞，降低吞吐量（例如生产者速度远快于消费者）。 收益：简化并发控制逻辑，避免锁竞争和缓冲区管理复杂性。 三、对比异步非阻塞通信 1. 异步通信的特点 缓冲通道：允许数据暂存，发送方写入后立即返回，无需等待接收方就绪。 解耦时序：生产者与消费者可以独立运行（如消息队列）。 2. 同步 vs 异步的权衡 维度 同步阻塞 异步非阻塞 数据一致性 强保证（直接传递） 弱保证（存在中间状态） 系统吞吐量 较低（依赖双方速度匹配） 较高（允许临时堆积） 资源占用 无缓冲区内存开销 需预分配缓冲区内存 适用场景 强时序依赖（如事务操作） 解耦生产消费（如日志处理） 四、同步阻塞的设计哲学 1. 消除竞态条件的根源 无共享内存：通过通信传递数据所有权，而非共享内存地址，天然避免多线程读写冲突。 隐式锁机制：同步过程隐含互斥语义，开发者无需手动管理锁。 2. 增强程序确定性 严格的事件顺序：通信的同步性使得程序行为更可预测，便于调试和形式化验证。 死锁显性化：若设计不当，同步阻塞会直接导致死锁（而非隐蔽的数据错误），迫使开发者提前解决逻辑漏洞。 3. 与现实世界的映射 物理世界交互：许多现实场景（如握手、合同签署）本质是同步的，要求双方共同参与。 逻辑事务性：例如银行转账需双方账户同时更新，异步设计可能导致中间态不一致。 五、实践中的模式与陷阱 1. 同步通信的经典模式 Rendezvous（汇合点）：两个协程通过无缓冲通道交换数据，实现逻辑同步。 Pipeline（流水线）：多个阶段通过同步通道串联，强制上下游速率匹配。 2. 常见陷阱与解决方案 死锁：协程间循环等待通道操作。 解决方案：使用 select 添加超时或退出信号。 1 2 3 4 5 6 select { case ch \u003c- data: // 正常发送 case \u003c-time.After(1 * time.Second): // 超时处理 } 协程泄漏：未关闭的通道导致阻塞协程无法退出。 防御措施：通过 context.Context 传递终止信号，确保资源回收。 六、总结 CSP 模型的同步阻塞通信通过强制发送方和接收方的“同时就绪”，将并发交互抽象为原子操作，其核心价值在于：\n简化并发控制：开发者无需关注锁、信号量等底层机制。 增强可靠性：通过时序约束消除中间状态的不确定性。 贴近现实逻辑：映射物理世界中的同步事务。 理解这一机制的关键在于：同步是通信的代价，也是安全的保障。在实际开发中，应根据场景需求选择同步或异步策略——需强一致性时使用无缓冲通道，需吞吐量时引入缓冲，但始终警惕异步可能带来的复杂性。\n","wordCount":"1547","inLanguage":"zh","image":"https://00001011b.github.io/images/author.jpg","datePublished":"2025-06-24T23:41:15+08:00","dateModified":"2025-06-24T23:41:15+08:00","author":{"@type":"Person","name":"陈十一"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://00001011b.github.io/posts/tech/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/"},"publisher":{"@type":"Organization","name":"落魄山","logo":{"@type":"ImageObject","url":"https://00001011b.github.io/images/author.jpg"}}}</script><script src=/js/iconfont.js></script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://00001011b.github.io/ accesskey=h title="落魄山 (Alt + H)"><img src=https://00001011b.github.io/images/author.jpg alt aria-label=logo height=35>落魄山</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://00001011b.github.io/tags/ title=🍥标签><span>🍥标签</span></a></li><li><a href=https://00001011b.github.io/archives/ title=🍣时间轴><span>🍣时间轴</span></a></li><li><a href=https://00001011b.github.io/about/ title=🍚关于><span>🍚关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">如何理解同步阻塞通信</h1><div class=post-meta><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guanyuwomen"/></svg>&nbsp;<span>陈十一</span> &nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-rili"/></svg>&nbsp;<span title='2025-06-24 23:41:15 +0800 +0800'>&nbsp;2025-06-24</span>&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-pinpaigushi"/></svg>&nbsp;1547字&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-shijian"/></svg>: 4分钟</div></header><div class=post-content><p>在 CSP（Communicating Sequential Processes）模型中，<strong>同步阻塞通信</strong>是核心设计原则之一，它定义了进程间数据传递的严格时序约束。以下通过多个维度深入解析这一机制的本质和意义：</p><hr><h3 id=一同步阻塞的本质原子性握手>一、同步阻塞的本质：<strong>原子性握手</strong><a hidden class=anchor aria-hidden=true href=#一同步阻塞的本质原子性握手>#</a></h3><h4 id=1-通信的即时性>1. <strong>通信的即时性</strong><a hidden class=anchor aria-hidden=true href=#1-通信的即时性>#</a></h4><ul><li><strong>定义</strong>：发送方（Sender）和接收方（Receiver）必须同时处于“就绪状态”（即同时调用发送和接收操作），才能完成一次数据传递。</li><li><strong>类比</strong>：类似打电话——双方必须同时拿起电话才能通话；若一方未接听，另一方会持续等待（阻塞）。</li></ul><h4 id=2-数据传递的原子性>2. <strong>数据传递的原子性</strong><a hidden class=anchor aria-hidden=true href=#2-数据传递的原子性>#</a></h4><ul><li><strong>零中间状态</strong>：数据直接从发送方内存复制到接收方内存，中间不经过任何缓冲区。</li><li><strong>无竞态风险</strong>：由于通信是瞬时完成的，不存在“发送一半数据”或“部分写入”的中间状态，天然避免数据不一致问题。</li></ul><h4 id=3-时序强制同步>3. <strong>时序强制同步</strong><a hidden class=anchor aria-hidden=true href=#3-时序强制同步>#</a></h4><ul><li><strong>因果关系绑定</strong>：发送操作 <code>P!data</code> 和接收操作 <code>Q?x</code> 必须成对出现，且逻辑上视为同一时间点发生的事件。</li><li><strong>语义等价</strong>：从外部观察者视角，发送和接收是同时完成的，类似于量子纠缠态的坍缩。</li></ul><hr><h3 id=二同步阻塞的底层实现>二、同步阻塞的底层实现<a hidden class=anchor aria-hidden=true href=#二同步阻塞的底层实现>#</a></h3><h4 id=1-无缓冲通道的阻塞行为以-go-为例>1. <strong>无缓冲通道的阻塞行为</strong>（以 Go 为例）<a hidden class=anchor aria-hidden=true href=#1-无缓冲通道的阻塞行为以-go-为例>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 无缓冲通道</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 发送方协程</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span> <span class=o>:=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>data</span> <span class=c1>// 阻塞，直到接收方就绪</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Sent&#34;</span><span class=p>)</span> <span class=c1>// 发送完成后执行</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 接收方协程</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>result</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span> <span class=c1>// 阻塞，直到发送方就绪</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Received:&#34;</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>运行时行为</strong>：若发送方先执行 <code>ch &lt;- data</code>，其协程会被挂起，加入通道的 <code>sendq</code> 等待队列；接收方就绪后，调度器唤醒双方并直接拷贝数据。</li></ul><h4 id=2-同步的代价与收益>2. <strong>同步的代价与收益</strong><a hidden class=anchor aria-hidden=true href=#2-同步的代价与收益>#</a></h4><ul><li><strong>代价</strong>：可能导致协程阻塞，降低吞吐量（例如生产者速度远快于消费者）。</li><li><strong>收益</strong>：简化并发控制逻辑，避免锁竞争和缓冲区管理复杂性。</li></ul><hr><h3 id=三对比异步非阻塞通信>三、对比异步非阻塞通信<a hidden class=anchor aria-hidden=true href=#三对比异步非阻塞通信>#</a></h3><h4 id=1-异步通信的特点>1. <strong>异步通信的特点</strong><a hidden class=anchor aria-hidden=true href=#1-异步通信的特点>#</a></h4><ul><li><strong>缓冲通道</strong>：允许数据暂存，发送方写入后立即返回，无需等待接收方就绪。</li><li><strong>解耦时序</strong>：生产者与消费者可以独立运行（如消息队列）。</li></ul><h4 id=2-同步-vs-异步的权衡>2. <strong>同步 vs 异步的权衡</strong><a hidden class=anchor aria-hidden=true href=#2-同步-vs-异步的权衡>#</a></h4><table><thead><tr><th><strong>维度</strong></th><th><strong>同步阻塞</strong></th><th><strong>异步非阻塞</strong></th></tr></thead><tbody><tr><td>数据一致性</td><td>强保证（直接传递）</td><td>弱保证（存在中间状态）</td></tr><tr><td>系统吞吐量</td><td>较低（依赖双方速度匹配）</td><td>较高（允许临时堆积）</td></tr><tr><td>资源占用</td><td>无缓冲区内存开销</td><td>需预分配缓冲区内存</td></tr><tr><td>适用场景</td><td>强时序依赖（如事务操作）</td><td>解耦生产消费（如日志处理）</td></tr></tbody></table><hr><h3 id=四同步阻塞的设计哲学>四、同步阻塞的设计哲学<a hidden class=anchor aria-hidden=true href=#四同步阻塞的设计哲学>#</a></h3><h4 id=1-消除竞态条件的根源>1. <strong>消除竞态条件的根源</strong><a hidden class=anchor aria-hidden=true href=#1-消除竞态条件的根源>#</a></h4><ul><li><strong>无共享内存</strong>：通过通信传递数据所有权，而非共享内存地址，天然避免多线程读写冲突。</li><li><strong>隐式锁机制</strong>：同步过程隐含互斥语义，开发者无需手动管理锁。</li></ul><h4 id=2-增强程序确定性>2. <strong>增强程序确定性</strong><a hidden class=anchor aria-hidden=true href=#2-增强程序确定性>#</a></h4><ul><li><strong>严格的事件顺序</strong>：通信的同步性使得程序行为更可预测，便于调试和形式化验证。</li><li><strong>死锁显性化</strong>：若设计不当，同步阻塞会直接导致死锁（而非隐蔽的数据错误），迫使开发者提前解决逻辑漏洞。</li></ul><h4 id=3-与现实世界的映射>3. <strong>与现实世界的映射</strong><a hidden class=anchor aria-hidden=true href=#3-与现实世界的映射>#</a></h4><ul><li><strong>物理世界交互</strong>：许多现实场景（如握手、合同签署）本质是同步的，要求双方共同参与。</li><li><strong>逻辑事务性</strong>：例如银行转账需双方账户同时更新，异步设计可能导致中间态不一致。</li></ul><hr><h3 id=五实践中的模式与陷阱>五、实践中的模式与陷阱<a hidden class=anchor aria-hidden=true href=#五实践中的模式与陷阱>#</a></h3><h4 id=1-同步通信的经典模式>1. <strong>同步通信的经典模式</strong><a hidden class=anchor aria-hidden=true href=#1-同步通信的经典模式>#</a></h4><ul><li><strong>Rendezvous（汇合点）</strong>：两个协程通过无缓冲通道交换数据，实现逻辑同步。</li><li><strong>Pipeline（流水线）</strong>：多个阶段通过同步通道串联，强制上下游速率匹配。</li></ul><h4 id=2-常见陷阱与解决方案>2. <strong>常见陷阱与解决方案</strong><a hidden class=anchor aria-hidden=true href=#2-常见陷阱与解决方案>#</a></h4><ul><li><strong>死锁</strong>：协程间循环等待通道操作。</li><li><strong>解决方案</strong>：使用 <code>select</code> 添加超时或退出信号。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>data</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 正常发送</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 超时处理</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>协程泄漏</strong>：未关闭的通道导致阻塞协程无法退出。</li><li><strong>防御措施</strong>：通过 <code>context.Context</code> 传递终止信号，确保资源回收。</li></ul><hr><h3 id=六总结>六、总结<a hidden class=anchor aria-hidden=true href=#六总结>#</a></h3><p>CSP 模型的<strong>同步阻塞通信</strong>通过强制发送方和接收方的“同时就绪”，将并发交互抽象为原子操作，其核心价值在于：</p><ol><li><strong>简化并发控制</strong>：开发者无需关注锁、信号量等底层机制。</li><li><strong>增强可靠性</strong>：通过时序约束消除中间状态的不确定性。</li><li><strong>贴近现实逻辑</strong>：映射物理世界中的同步事务。</li></ol><p>理解这一机制的关键在于：<strong>同步是通信的代价，也是安全的保障</strong>。在实际开发中，应根据场景需求选择同步或异步策略——需强一致性时使用无缓冲通道，需吞吐量时引入缓冲，但始终警惕异步可能带来的复杂性。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://00001011b.github.io/tags/channel/>Channel</a></li></ul><nav class=paginav><a class=prev href=https://00001011b.github.io/posts/tech/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%B1%E5%8F%91%E9%80%81%E6%96%B9%E5%85%B3%E9%97%ADchannel/><span class=title>« 上一页</span><br><span>为什么由发送方关闭channel</span>
</a><a class=next href=https://00001011b.github.io/posts/tech/golang-channel/><span class=title>下一页 »</span><br><span>Golang Channel</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://00001011b.github.io/>落魄山</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>