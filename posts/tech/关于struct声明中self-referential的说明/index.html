<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于 struct 声明中 self Referential 的说明 | 落魄山</title>
<meta name=keywords content><meta name=description content="在《The C programming language, second edition》的 section A8.3 中，有这么一段话：

A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><meta name=author content="陈十一"><link rel=canonical href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0b04ef4965a7780bb1a0683ad3d24630b924ce9b43d845a958e4d779ee2b77bc.css integrity="sha256-CwTvSWWneAuxoGg609JGMLkkzptD2EWpWOTXee4rd7w=" rel="preload stylesheet" as=style><link rel=icon href=https://00001011b.github.io/images/author.jpg><link rel=icon type=image/png sizes=16x16 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"><meta property="og:site_name" content="落魄山"><meta property="og:title" content="关于 struct 声明中 self Referential 的说明"><meta property="og:description" content="在《The C programming language, second edition》的 section A8.3 中，有这么一段话：
A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T00:43:51+08:00"><meta property="article:modified_time" content="2023-06-27T00:43:51+08:00"><meta property="og:image" content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:title content="关于 struct 声明中 self Referential 的说明"><meta name=twitter:description content="在《The C programming language, second edition》的 section A8.3 中，有这么一段话：

A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://00001011b.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://00001011b.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"关于 struct 声明中 self Referential 的说明","item":"https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于 struct 声明中 self Referential 的说明","name":"关于 struct 声明中 self Referential 的说明","description":"在《The C programming language, second edition》的 section A8.3 中，有这么一段话：\nA structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.\n","keywords":[],"articleBody":"在《The C programming language, second edition》的 section A8.3 中，有这么一段话：\nA structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.\n我对 it is impossible to declare a structure or union containing an instance of itself. 百思不得其解，因此探索了一番。\n原因(中文) 在 C 编程中，不可能直接声明一个包含自身实例的结构体或联合体。这个限制被称为\"自引用\"或\"递归\"声明，与内存分配和结构体大小确定的方式有关。\n当声明一个结构体或联合体时，编译器需要知道结构体的大小以便为其分配内存。然而，如果一个结构体包含自身的实例，结构体的大小就变得不确定，无法确定。\n我们来举个例子来说明这个问题：\n1 2 3 4 struct Node { int data; struct Node next; // 错误的声明：结构体包含自身实例 }; 在上面的例子中，定义了一个 Node 结构体，其中包含了同样是 Node 结构体类型的成员 next。问题在于编译器无法确定 Node 的大小，因为它取决于 next 的大小，而 next 又是一个 Node 结构体。这就形成了递归定义，导致结构体的大小变得无限大。\n为了解决这个限制，可以使用指针来实现自引用的行为。以下是一个更新后的示例：\n1 2 3 4 struct Node { int data; struct Node* next; // 正确的声明：使用结构体的指针 }; 在这个修改后的示例中，next 成员被声明为指向 Node 结构体的指针（struct Node*），而不是直接嵌套一个结构体实例。指针的大小是固定的，不管它指向的类型是什么，因此可以正确确定结构体的大小。\n通过使用指针，可以创建链式结构或递归数据结构，其中每个节点指向另一个节点，从而实现更灵活和动态的内存分配。\n总结起来，在C语言中无法直接声明包含自身实例的结构体或联合体，是因为难以确定这种结构体的大小。但是，可以使用指针来实现类似的自引用行为，创建递归或链式数据结构。\nanswer In C programming, it is not possible to declare a structure or union that contains an instance of itself directly. This limitation is known as “self-referential” or “recursive” declaration, and it is related to the way memory is allocated and the size of the structure is determined.\nWhen a structure or union is declared, the compiler needs to know the size of the structure in order to allocate memory for it. However, if a structure contains an instance of itself, the size of the structure becomes indefinite and cannot be determined.\nLet’s take an example to illustrate this issue:\n1 2 3 4 struct Node { int data; struct Node next; // Incorrect declaration: structure contains an instance of itself }; In the above example, the Node structure is defined with a member next of the same structure type Node. The problem here is that the compiler cannot determine the size of Node because it depends on the size of next, which is itself a Node structure. This creates a recursive definition and leads to an infinite size for the structure.\nTo overcome this limitation, you can use pointers to achieve self-referential behavior. Here’s an updated example:\n1 2 3 4 struct Node { int data; struct Node* next; // Correct declaration: using a pointer to the structure }; In this modified example, the next member is declared as a pointer to the Node structure (struct Node*), rather than directly embedding an instance of the structure. Pointers have a fixed size, regardless of the type they are pointing to, so the size of the structure can be determined correctly.\nBy using pointers, you can create linked structures or recursive data structures where each node points to another node, allowing for more flexible and dynamic memory allocation.\nIn summary, the inability to declare a structure or union containing an instance of itself directly in C is due to the challenge of determining the size of such a structure. However, you can use pointers to achieve similar self-referential behavior and create recursive or linked data structures.\n","wordCount":"1075","inLanguage":"zh","image":"https://00001011b.github.io/images/author.jpg","datePublished":"2023-06-27T00:43:51+08:00","dateModified":"2023-06-27T00:43:51+08:00","author":{"@type":"Person","name":"陈十一"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"},"publisher":{"@type":"Organization","name":"落魄山","logo":{"@type":"ImageObject","url":"https://00001011b.github.io/images/author.jpg"}}}</script><script src=/js/iconfont.js></script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://00001011b.github.io/ accesskey=h title="落魄山 (Alt + H)"><img src=https://00001011b.github.io/images/author.jpg alt aria-label=logo height=35>落魄山</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://00001011b.github.io/tags/ title=🍥标签><span>🍥标签</span></a></li><li><a href=https://00001011b.github.io/archives/ title=🍣时间轴><span>🍣时间轴</span></a></li><li><a href=https://00001011b.github.io/about/ title=🍚关于><span>🍚关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">关于 struct 声明中 self Referential 的说明</h1><div class=post-meta><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guanyuwomen"/></svg>&nbsp;<span>陈十一</span> &nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-rili"/></svg>&nbsp;<span title='2023-06-27 00:43:51 +0800 +0800'>&nbsp;2023-06-27</span>&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-pinpaigushi"/></svg>&nbsp;1075字&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-shijian"/></svg>: 3分钟</div></header><div class=post-content><p>在<a href=https://book.douban.com/subject/1882483/>《The C programming language, second edition》</a>的 section A8.3 中，有这么一段话：</p><blockquote><p>A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.</p></blockquote><p>我对 <code>it is impossible to declare a structure or union containing an instance of itself.</code> 百思不得其解，因此探索了一番。</p><h3 id=原因中文>原因(中文)<a hidden class=anchor aria-hidden=true href=#原因中文>#</a></h3><p>在 C 编程中，不可能直接声明一个包含自身实例的结构体或联合体。这个限制被称为"自引用"或"递归"声明，与内存分配和结构体大小确定的方式有关。</p><p>当声明一个结构体或联合体时，编译器需要知道结构体的大小以便为其分配内存。然而，如果一个结构体包含自身的实例，结构体的大小就变得不确定，无法确定。</p><p>我们来举个例子来说明这个问题：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// 错误的声明：结构体包含自身实例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，定义了一个 <code>Node</code> 结构体，其中包含了同样是 <code>Node</code> 结构体类型的成员 <code>next</code>。问题在于编译器无法确定 <code>Node</code> 的大小，因为它取决于 <code>next</code> 的大小，而 <code>next</code> 又是一个 <code>Node</code> 结构体。这就形成了递归定义，导致结构体的大小变得无限大。</p><p>为了解决这个限制，可以使用指针来实现自引用的行为。以下是一个更新后的示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// 正确的声明：使用结构体的指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个修改后的示例中，<code>next</code> 成员被声明为指向 <code>Node</code> 结构体的指针（<code>struct Node*</code>），而不是直接嵌套一个结构体实例。指针的大小是固定的，不管它指向的类型是什么，因此可以正确确定结构体的大小。</p><p>通过使用指针，可以创建链式结构或递归数据结构，其中每个节点指向另一个节点，从而实现更灵活和动态的内存分配。</p><p>总结起来，在C语言中无法直接声明包含自身实例的结构体或联合体，是因为难以确定这种结构体的大小。但是，可以使用指针来实现类似的自引用行为，创建递归或链式数据结构。</p><h3 id=answer>answer<a hidden class=anchor aria-hidden=true href=#answer>#</a></h3><p>In C programming, it is not possible to declare a structure or union that contains an instance of itself directly. This limitation is known as &ldquo;self-referential&rdquo; or &ldquo;recursive&rdquo; declaration, and it is related to the way memory is allocated and the size of the structure is determined.</p><p>When a structure or union is declared, the compiler needs to know the size of the structure in order to allocate memory for it. However, if a structure contains an instance of itself, the size of the structure becomes indefinite and cannot be determined.</p><p>Let&rsquo;s take an example to illustrate this issue:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// Incorrect declaration: structure contains an instance of itself
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above example, the <code>Node</code> structure is defined with a member <code>next</code> of the same structure type <code>Node</code>. The problem here is that the compiler cannot determine the size of <code>Node</code> because it depends on the size of <code>next</code>, which is itself a <code>Node</code> structure. This creates a recursive definition and leads to an infinite size for the structure.</p><p>To overcome this limitation, you can use pointers to achieve self-referential behavior. Here&rsquo;s an updated example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// Correct declaration: using a pointer to the structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this modified example, the <code>next</code> member is declared as a pointer to the <code>Node</code> structure (<code>struct Node*</code>), rather than directly embedding an instance of the structure. Pointers have a fixed size, regardless of the type they are pointing to, so the size of the structure can be determined correctly.</p><p>By using pointers, you can create linked structures or recursive data structures where each node points to another node, allowing for more flexible and dynamic memory allocation.</p><p>In summary, the inability to declare a structure or union containing an instance of itself directly in C is due to the challenge of determining the size of such a structure. However, you can use pointers to achieve similar self-referential behavior and create recursive or linked data structures.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://00001011b.github.io/posts/think/%E9%97%AE%E5%BF%83%E5%B1%80%E4%BA%8C/><span class=title>« 上一页</span><br><span>问心局二</span>
</a><a class=next href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84specifier%E5%92%8Cqualifier/><span class=title>下一页 »</span><br><span>关于 C 语言里的 specifier 和 qualifier</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://00001011b.github.io/>落魄山</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>