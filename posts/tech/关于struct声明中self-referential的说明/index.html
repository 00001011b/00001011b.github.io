<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜ | è½é­„å±±</title>
<meta name=keywords content><meta name=description content="åœ¨ã€ŠThe C programming language, second editionã€‹çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š

A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><meta name=author content="é™ˆåä¸€"><link rel=canonical href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0b04ef4965a7780bb1a0683ad3d24630b924ce9b43d845a958e4d779ee2b77bc.css integrity="sha256-CwTvSWWneAuxoGg609JGMLkkzptD2EWpWOTXee4rd7w=" rel="preload stylesheet" as=style><link rel=icon href=https://00001011b.github.io/images/author.jpg><link rel=icon type=image/png sizes=16x16 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"><meta property="og:site_name" content="è½é­„å±±"><meta property="og:title" content="å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜"><meta property="og:description" content="åœ¨ã€ŠThe C programming language, second editionã€‹çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š
A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T00:43:51+08:00"><meta property="article:modified_time" content="2023-06-27T00:43:51+08:00"><meta property="og:image" content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:title content="å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜"><meta name=twitter:description content="åœ¨ã€ŠThe C programming language, second editionã€‹çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š

A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://00001011b.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://00001011b.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜","item":"https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜","name":"å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜","description":"åœ¨ã€ŠThe C programming language, second editionã€‹çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š\nA structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.\n","keywords":[],"articleBody":"åœ¨ã€ŠThe C programming language, second editionã€‹çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š\nA structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.\næˆ‘å¯¹ it is impossible to declare a structure or union containing an instance of itself. ç™¾æ€ä¸å¾—å…¶è§£ï¼Œå› æ­¤æ¢ç´¢äº†ä¸€ç•ªã€‚\nåŸå› (ä¸­æ–‡) åœ¨ C ç¼–ç¨‹ä¸­ï¼Œä¸å¯èƒ½ç›´æ¥å£°æ˜ä¸€ä¸ªåŒ…å«è‡ªèº«å®ä¾‹çš„ç»“æ„ä½“æˆ–è”åˆä½“ã€‚è¿™ä¸ªé™åˆ¶è¢«ç§°ä¸º\"è‡ªå¼•ç”¨\"æˆ–\"é€’å½’\"å£°æ˜ï¼Œä¸å†…å­˜åˆ†é…å’Œç»“æ„ä½“å¤§å°ç¡®å®šçš„æ–¹å¼æœ‰å…³ã€‚\nå½“å£°æ˜ä¸€ä¸ªç»“æ„ä½“æˆ–è”åˆä½“æ—¶ï¼Œç¼–è¯‘å™¨éœ€è¦çŸ¥é“ç»“æ„ä½“çš„å¤§å°ä»¥ä¾¿ä¸ºå…¶åˆ†é…å†…å­˜ã€‚ç„¶è€Œï¼Œå¦‚æœä¸€ä¸ªç»“æ„ä½“åŒ…å«è‡ªèº«çš„å®ä¾‹ï¼Œç»“æ„ä½“çš„å¤§å°å°±å˜å¾—ä¸ç¡®å®šï¼Œæ— æ³•ç¡®å®šã€‚\næˆ‘ä»¬æ¥ä¸¾ä¸ªä¾‹å­æ¥è¯´æ˜è¿™ä¸ªé—®é¢˜ï¼š\n1 2 3 4 struct Node { int data; struct Node next; // é”™è¯¯çš„å£°æ˜ï¼šç»“æ„ä½“åŒ…å«è‡ªèº«å®ä¾‹ }; åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ª Node ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«äº†åŒæ ·æ˜¯ Node ç»“æ„ä½“ç±»å‹çš„æˆå‘˜ nextã€‚é—®é¢˜åœ¨äºç¼–è¯‘å™¨æ— æ³•ç¡®å®š Node çš„å¤§å°ï¼Œå› ä¸ºå®ƒå–å†³äº next çš„å¤§å°ï¼Œè€Œ next åˆæ˜¯ä¸€ä¸ª Node ç»“æ„ä½“ã€‚è¿™å°±å½¢æˆäº†é€’å½’å®šä¹‰ï¼Œå¯¼è‡´ç»“æ„ä½“çš„å¤§å°å˜å¾—æ— é™å¤§ã€‚\nä¸ºäº†è§£å†³è¿™ä¸ªé™åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨æŒ‡é’ˆæ¥å®ç°è‡ªå¼•ç”¨çš„è¡Œä¸ºã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ›´æ–°åçš„ç¤ºä¾‹ï¼š\n1 2 3 4 struct Node { int data; struct Node* next; // æ­£ç¡®çš„å£°æ˜ï¼šä½¿ç”¨ç»“æ„ä½“çš„æŒ‡é’ˆ }; åœ¨è¿™ä¸ªä¿®æ”¹åçš„ç¤ºä¾‹ä¸­ï¼Œnext æˆå‘˜è¢«å£°æ˜ä¸ºæŒ‡å‘ Node ç»“æ„ä½“çš„æŒ‡é’ˆï¼ˆstruct Node*ï¼‰ï¼Œè€Œä¸æ˜¯ç›´æ¥åµŒå¥—ä¸€ä¸ªç»“æ„ä½“å®ä¾‹ã€‚æŒ‡é’ˆçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œä¸ç®¡å®ƒæŒ‡å‘çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå› æ­¤å¯ä»¥æ­£ç¡®ç¡®å®šç»“æ„ä½“çš„å¤§å°ã€‚\né€šè¿‡ä½¿ç”¨æŒ‡é’ˆï¼Œå¯ä»¥åˆ›å»ºé“¾å¼ç»“æ„æˆ–é€’å½’æ•°æ®ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»è€Œå®ç°æ›´çµæ´»å’ŒåŠ¨æ€çš„å†…å­˜åˆ†é…ã€‚\næ€»ç»“èµ·æ¥ï¼Œåœ¨Cè¯­è¨€ä¸­æ— æ³•ç›´æ¥å£°æ˜åŒ…å«è‡ªèº«å®ä¾‹çš„ç»“æ„ä½“æˆ–è”åˆä½“ï¼Œæ˜¯å› ä¸ºéš¾ä»¥ç¡®å®šè¿™ç§ç»“æ„ä½“çš„å¤§å°ã€‚ä½†æ˜¯ï¼Œå¯ä»¥ä½¿ç”¨æŒ‡é’ˆæ¥å®ç°ç±»ä¼¼çš„è‡ªå¼•ç”¨è¡Œä¸ºï¼Œåˆ›å»ºé€’å½’æˆ–é“¾å¼æ•°æ®ç»“æ„ã€‚\nanswer In C programming, it is not possible to declare a structure or union that contains an instance of itself directly. This limitation is known as â€œself-referentialâ€ or â€œrecursiveâ€ declaration, and it is related to the way memory is allocated and the size of the structure is determined.\nWhen a structure or union is declared, the compiler needs to know the size of the structure in order to allocate memory for it. However, if a structure contains an instance of itself, the size of the structure becomes indefinite and cannot be determined.\nLetâ€™s take an example to illustrate this issue:\n1 2 3 4 struct Node { int data; struct Node next; // Incorrect declaration: structure contains an instance of itself }; In the above example, the Node structure is defined with a member next of the same structure type Node. The problem here is that the compiler cannot determine the size of Node because it depends on the size of next, which is itself a Node structure. This creates a recursive definition and leads to an infinite size for the structure.\nTo overcome this limitation, you can use pointers to achieve self-referential behavior. Hereâ€™s an updated example:\n1 2 3 4 struct Node { int data; struct Node* next; // Correct declaration: using a pointer to the structure }; In this modified example, the next member is declared as a pointer to the Node structure (struct Node*), rather than directly embedding an instance of the structure. Pointers have a fixed size, regardless of the type they are pointing to, so the size of the structure can be determined correctly.\nBy using pointers, you can create linked structures or recursive data structures where each node points to another node, allowing for more flexible and dynamic memory allocation.\nIn summary, the inability to declare a structure or union containing an instance of itself directly in C is due to the challenge of determining the size of such a structure. However, you can use pointers to achieve similar self-referential behavior and create recursive or linked data structures.\n","wordCount":"1075","inLanguage":"zh","image":"https://00001011b.github.io/images/author.jpg","datePublished":"2023-06-27T00:43:51+08:00","dateModified":"2023-06-27T00:43:51+08:00","author":{"@type":"Person","name":"é™ˆåä¸€"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Estruct%E5%A3%B0%E6%98%8E%E4%B8%ADself-referential%E7%9A%84%E8%AF%B4%E6%98%8E/"},"publisher":{"@type":"Organization","name":"è½é­„å±±","logo":{"@type":"ImageObject","url":"https://00001011b.github.io/images/author.jpg"}}}</script><script src=/js/iconfont.js></script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://00001011b.github.io/ accesskey=h title="è½é­„å±± (Alt + H)"><img src=https://00001011b.github.io/images/author.jpg alt aria-label=logo height=35>è½é­„å±±</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://00001011b.github.io/tags/ title=ğŸ¥æ ‡ç­¾><span>ğŸ¥æ ‡ç­¾</span></a></li><li><a href=https://00001011b.github.io/archives/ title=ğŸ£æ—¶é—´è½´><span>ğŸ£æ—¶é—´è½´</span></a></li><li><a href=https://00001011b.github.io/about/ title=ğŸšå…³äº><span>ğŸšå…³äº</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">å…³äº struct å£°æ˜ä¸­ self Referential çš„è¯´æ˜</h1><div class=post-meta><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guanyuwomen"/></svg>&nbsp;<span>é™ˆåä¸€</span> &nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-rili"/></svg>&nbsp;<span title='2023-06-27 00:43:51 +0800 +0800'>&nbsp;2023-06-27</span>&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-pinpaigushi"/></svg>&nbsp;1075å­—&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-shijian"/></svg>: 3åˆ†é’Ÿ</div></header><div class=post-content><p>åœ¨<a href=https://book.douban.com/subject/1882483/>ã€ŠThe C programming language, second editionã€‹</a>çš„ section A8.3 ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ®µè¯ï¼š</p><blockquote><p>A structure may not contain a member of incomplete type. Therefore, it is impossible to declare a structure or union containing an instance of itself. However, besides giving a name to the structure or union type, tags allow definition of self-referential structures; a structure or union may contain a pointer to an instance of itself, because pointers to incomplete types may be declared.</p></blockquote><p>æˆ‘å¯¹ <code>it is impossible to declare a structure or union containing an instance of itself.</code> ç™¾æ€ä¸å¾—å…¶è§£ï¼Œå› æ­¤æ¢ç´¢äº†ä¸€ç•ªã€‚</p><h3 id=åŸå› ä¸­æ–‡>åŸå› (ä¸­æ–‡)<a hidden class=anchor aria-hidden=true href=#åŸå› ä¸­æ–‡>#</a></h3><p>åœ¨ C ç¼–ç¨‹ä¸­ï¼Œä¸å¯èƒ½ç›´æ¥å£°æ˜ä¸€ä¸ªåŒ…å«è‡ªèº«å®ä¾‹çš„ç»“æ„ä½“æˆ–è”åˆä½“ã€‚è¿™ä¸ªé™åˆ¶è¢«ç§°ä¸º"è‡ªå¼•ç”¨"æˆ–"é€’å½’"å£°æ˜ï¼Œä¸å†…å­˜åˆ†é…å’Œç»“æ„ä½“å¤§å°ç¡®å®šçš„æ–¹å¼æœ‰å…³ã€‚</p><p>å½“å£°æ˜ä¸€ä¸ªç»“æ„ä½“æˆ–è”åˆä½“æ—¶ï¼Œç¼–è¯‘å™¨éœ€è¦çŸ¥é“ç»“æ„ä½“çš„å¤§å°ä»¥ä¾¿ä¸ºå…¶åˆ†é…å†…å­˜ã€‚ç„¶è€Œï¼Œå¦‚æœä¸€ä¸ªç»“æ„ä½“åŒ…å«è‡ªèº«çš„å®ä¾‹ï¼Œç»“æ„ä½“çš„å¤§å°å°±å˜å¾—ä¸ç¡®å®šï¼Œæ— æ³•ç¡®å®šã€‚</p><p>æˆ‘ä»¬æ¥ä¸¾ä¸ªä¾‹å­æ¥è¯´æ˜è¿™ä¸ªé—®é¢˜ï¼š</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// é”™è¯¯çš„å£°æ˜ï¼šç»“æ„ä½“åŒ…å«è‡ªèº«å®ä¾‹
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ª <code>Node</code> ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«äº†åŒæ ·æ˜¯ <code>Node</code> ç»“æ„ä½“ç±»å‹çš„æˆå‘˜ <code>next</code>ã€‚é—®é¢˜åœ¨äºç¼–è¯‘å™¨æ— æ³•ç¡®å®š <code>Node</code> çš„å¤§å°ï¼Œå› ä¸ºå®ƒå–å†³äº <code>next</code> çš„å¤§å°ï¼Œè€Œ <code>next</code> åˆæ˜¯ä¸€ä¸ª <code>Node</code> ç»“æ„ä½“ã€‚è¿™å°±å½¢æˆäº†é€’å½’å®šä¹‰ï¼Œå¯¼è‡´ç»“æ„ä½“çš„å¤§å°å˜å¾—æ— é™å¤§ã€‚</p><p>ä¸ºäº†è§£å†³è¿™ä¸ªé™åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨æŒ‡é’ˆæ¥å®ç°è‡ªå¼•ç”¨çš„è¡Œä¸ºã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ›´æ–°åçš„ç¤ºä¾‹ï¼š</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// æ­£ç¡®çš„å£°æ˜ï¼šä½¿ç”¨ç»“æ„ä½“çš„æŒ‡é’ˆ
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>åœ¨è¿™ä¸ªä¿®æ”¹åçš„ç¤ºä¾‹ä¸­ï¼Œ<code>next</code> æˆå‘˜è¢«å£°æ˜ä¸ºæŒ‡å‘ <code>Node</code> ç»“æ„ä½“çš„æŒ‡é’ˆï¼ˆ<code>struct Node*</code>ï¼‰ï¼Œè€Œä¸æ˜¯ç›´æ¥åµŒå¥—ä¸€ä¸ªç»“æ„ä½“å®ä¾‹ã€‚æŒ‡é’ˆçš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œä¸ç®¡å®ƒæŒ‡å‘çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå› æ­¤å¯ä»¥æ­£ç¡®ç¡®å®šç»“æ„ä½“çš„å¤§å°ã€‚</p><p>é€šè¿‡ä½¿ç”¨æŒ‡é’ˆï¼Œå¯ä»¥åˆ›å»ºé“¾å¼ç»“æ„æˆ–é€’å½’æ•°æ®ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»è€Œå®ç°æ›´çµæ´»å’ŒåŠ¨æ€çš„å†…å­˜åˆ†é…ã€‚</p><p>æ€»ç»“èµ·æ¥ï¼Œåœ¨Cè¯­è¨€ä¸­æ— æ³•ç›´æ¥å£°æ˜åŒ…å«è‡ªèº«å®ä¾‹çš„ç»“æ„ä½“æˆ–è”åˆä½“ï¼Œæ˜¯å› ä¸ºéš¾ä»¥ç¡®å®šè¿™ç§ç»“æ„ä½“çš„å¤§å°ã€‚ä½†æ˜¯ï¼Œå¯ä»¥ä½¿ç”¨æŒ‡é’ˆæ¥å®ç°ç±»ä¼¼çš„è‡ªå¼•ç”¨è¡Œä¸ºï¼Œåˆ›å»ºé€’å½’æˆ–é“¾å¼æ•°æ®ç»“æ„ã€‚</p><h3 id=answer>answer<a hidden class=anchor aria-hidden=true href=#answer>#</a></h3><p>In C programming, it is not possible to declare a structure or union that contains an instance of itself directly. This limitation is known as &ldquo;self-referential&rdquo; or &ldquo;recursive&rdquo; declaration, and it is related to the way memory is allocated and the size of the structure is determined.</p><p>When a structure or union is declared, the compiler needs to know the size of the structure in order to allocate memory for it. However, if a structure contains an instance of itself, the size of the structure becomes indefinite and cannot be determined.</p><p>Let&rsquo;s take an example to illustrate this issue:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// Incorrect declaration: structure contains an instance of itself
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In the above example, the <code>Node</code> structure is defined with a member <code>next</code> of the same structure type <code>Node</code>. The problem here is that the compiler cannot determine the size of <code>Node</code> because it depends on the size of <code>next</code>, which is itself a <code>Node</code> structure. This creates a recursive definition and leads to an infinite size for the structure.</p><p>To overcome this limitation, you can use pointers to achieve self-referential behavior. Here&rsquo;s an updated example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>Node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Node</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>  <span class=c1>// Correct declaration: using a pointer to the structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>In this modified example, the <code>next</code> member is declared as a pointer to the <code>Node</code> structure (<code>struct Node*</code>), rather than directly embedding an instance of the structure. Pointers have a fixed size, regardless of the type they are pointing to, so the size of the structure can be determined correctly.</p><p>By using pointers, you can create linked structures or recursive data structures where each node points to another node, allowing for more flexible and dynamic memory allocation.</p><p>In summary, the inability to declare a structure or union containing an instance of itself directly in C is due to the challenge of determining the size of such a structure. However, you can use pointers to achieve similar self-referential behavior and create recursive or linked data structures.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://00001011b.github.io/posts/think/%E9%97%AE%E5%BF%83%E5%B1%80%E4%BA%8C/><span class=title>Â« ä¸Šä¸€é¡µ</span><br><span>é—®å¿ƒå±€äºŒ</span>
</a><a class=next href=https://00001011b.github.io/posts/tech/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84specifier%E5%92%8Cqualifier/><span class=title>ä¸‹ä¸€é¡µ Â»</span><br><span>å…³äº C è¯­è¨€é‡Œçš„ specifier å’Œ qualifier</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://00001011b.github.io/>è½é­„å±±</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>