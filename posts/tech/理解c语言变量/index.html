<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>理解C语言变量 | 落魄山</title><meta name=keywords content><meta name=description content="变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。 1、标识符 标识符，"><meta name=author content="陈十一"><link rel=canonical href=https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.min.3dc5e5b28a604be4e081d755ce739fdc702f66cd1b13733d9c5c1d508cfa6e80.css integrity="sha256-PcXlsopgS+TggddVznOf3HAvZs0bE3M9nFwdUIz6boA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://00001011b.github.io/images/author.jpg><link rel=icon type=image/png sizes=16x16 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://00001011b.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="理解C语言变量"><meta property="og:description" content="变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。 1、标识符 标识符，"><meta property="og:type" content="article"><meta property="og:url" content="https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/"><meta property="og:image" content="https://00001011b.github.io/images/author.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-11T14:03:41+08:00"><meta property="article:modified_time" content="2023-06-11T14:03:41+08:00"><meta property="og:site_name" content="落魄山"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://00001011b.github.io/images/author.jpg"><meta name=twitter:title content="理解C语言变量"><meta name=twitter:description content="变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。 1、标识符 标识符，"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://00001011b.github.io/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://00001011b.github.io/posts/tech/"},{"@type":"ListItem","position":3,"name":"理解C语言变量","item":"https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"理解C语言变量","name":"理解C语言变量","description":"变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。 1、标识符 标识符，","keywords":[],"articleBody":"变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。\n1、标识符 标识符，本质上来讲，就是一个名字。通过这个名字，我们可以引用到（refers to） C 语言里的很多东西：\n函数（function）。 枚举、联合、结构体的标签（tags of enumeration, union and structure）。 联合、结构体的成员（members of union and structure）。 枚举常量（enumeration constant）。 用 typedef 创建的名字（typedef names）。 对象（object）。 标志符与生俱来就有两个属性。我们思考一下，当我们写下一个标识符的时候，会面临两个问题的：\n这个标志符的可见性是？ 如果我写了一个标识符：randomvalue，在别的模块里，别人也写了一样的标识符，那怎么办？ 这两个问题就延伸出两种极其重要的属性了。\nA name also has a scope, which is the region of the program in which it is known, and a linkage, which detemines whether the same name in another scope refers to the same object or function.\n即：一个名称（标识符）还具有作用域，即其所在的程序区域，在该区域内可以识别该名称，并且还具有链接性，决定了在另一个作用域中是否使用相同的名称引用相同的对象或函数。\n2、变量 根据上一节我们知道，标识符具有两个属性。\n作用域： 指在程序中定义的变量、函数或其他命名实体的可见性和有效范围。它决定了在程序的哪些部分可以访问和使用这些实体。作用域规定了变量或函数的名称在程序中的可访问范围，并且可以帮助避免命名冲突。\n链接性：指在程序中不同作用域中同名实体之间的关联性和连接性。它确定了同名实体在不同作用域中是否引用相同的对象或函数。\n变量是标识符的子集，因此也是天然继承了这两个属性的。除此之外，变量还有另外两个属性：存储类别（storage class）和类型（type）。\n下面，我要对变量的这四种属性进行细说。\n2.1、存储类别 在编程中，存储类别（storage class）是用于指定变量或函数的存储位置、生命周期和可见性的修饰符。\n在C语言中有以下存储类别：\nauto：默认的存储类别，用于指定局部变量的存储，表示变量在代码块中的自动创建和销毁。\nregister：用于请求将变量存储在寄存器中，以便快速访问。然而，这只是一个建议，编译器可以忽略它。\nstatic：用于指定静态变量的存储，这些变量在整个程序执行期间都存在，不会随着作用域的进入和退出而创建或销毁。\nextern：用于声明外部变量或函数，表示这些实体是在其他文件中定义的。\ntypedef：用于创建自定义的类型别名，不直接与存储相关，但在存储类别的讨论中常常提及。\n2.2、类型 在C语言中，类型（type）是用来描述数据的性质、大小和操作方式的概念。每个变量、表达式和函数都有一个特定的类型，它决定了该实体能够存储的数据范围、内存占用以及可对其执行的操作。\nC语言提供了多种基本类型和派生类型，包括但不限于以下几种：\n基本类型（Basic Types）：C语言提供了一些基本的数据类型，如整数类型（如int、char）、浮点数类型（如float、double）和布尔类型（_Bool）。这些类型用于存储基本的数据值。\n数组类型（Array Types）：数组是一种由相同类型的元素组成的集合，可以通过下标访问和操作其中的元素。\n结构体类型（Struct Types）：结构体是一种用户自定义的数据类型，它可以包含多个不同类型的成员变量。\n枚举类型（Enum Types）：枚举类型是一种用户自定义的类型，用于定义一组相关的命名常量。\n指针类型（Pointer Types）：指针是一种特殊的数据类型，它存储了其他类型数据对象的内存地址。\n函数类型（Function Types）：函数也具有类型，它描述了函数的返回值类型和参数类型。\n类型在C语言中具有重要的作用，它们决定了数据的表示和操作方式。在编程过程中，正确的类型使用可以确保数据的正确性和一致性，同时提供了对数据进行有效操作和处理的工具。\n例如，考虑以下代码片段：\n1 2 3 4 5 6 7 int x = 5; float y = 3.14; char c = 'A'; int add(int a, int b) { return a + b; } 在上述代码中，变量 x 的类型为 int，可以存储整数值。变量 y 的类型为 float，可以存储浮点数值。变量 c 的类型为 char，可以存储单个字符。函数 add 的类型为返回值为 int，参数为两个 int 类型的函数。\n理解C语言中的类型有助于正确声明和使用变量、函数和数据结构，并确保在操作数据时符合语言规范和预期行为。\n2.3、链接性 在C语言中，链接性（linkage）指的是标识符（变量、函数、常量等）在不同编译单元（源文件）之间的关联性和连接性。它确定了同名标识符在不同编译单元中是否引用相同的对象或函数。\nC语言中的链接性有以下几种类型：\n外部链接性（External Linkage）：具有外部链接性的标识符可以在不同的源文件之间共享和访问。它们在不同的编译单元中表示同一个实体。可以通过使用 extern 关键字来声明具有外部链接性的变量或函数。 例子：\n在源文件 A.c 中定义了一个具有外部链接性的全局变量：\n1 2 // A.c int globalVar = 10; 在源文件 B.c 中使用了外部链接性的全局变量：\n1 2 3 4 5 6 // B.c extern int globalVar; void myFunction() { // 在此可以使用 globalVar } 在上述示例中，全局变量 globalVar 在 A.c 中定义，具有外部链接性，然后在 B.c 中使用 extern 关键字声明，并在函数 myFunction 中访问。通过外部链接性，B.c 可以访问并共享 A.c 中定义的 globalVar。\n内部链接性（Internal Linkage）：具有内部链接性的标识符只能在定义它们的单个源文件中访问。它们在文件内部是可见的，但无法跨源文件共享。 例子：\n在源文件 A.c 中定义了一个具有内部链接性的静态变量：\n1 2 // A.c static int staticVar = 20; 在源文件 B.c 中无法访问具有内部链接性的静态变量：\n1 2 3 4 5 6 // B.c extern int staticVar; // 错误：无法访问具有内部链接性的静态变量 void myFunction() { // 无法访问 staticVar } 在上述示例中，静态变量 staticVar 在 A.c 中定义，具有内部链接性，只能在 A.c 内部访问。在 B.c 中使用 extern 关键字尝试访问 staticVar 会导致编译错误。\n需要注意的是，具有外部链接性和内部链接性的标识符可以是全局变量、静态变量或函数。它们的链接性是由标识符的声明或定义方式决定的。\n理解链接性的概念有助于编写模块化的代码，并控制标识符的可见性和共享性。它可以用于限制变量和函数的作用范围，避免命名冲突，并支持多文件的程序开发。\n链接性的概念在多文件的程序开发中尤为重要。通过定义具有外部链接性的变量或函数，可以在多个文件中共享它们，从而促进代码的模块化和重用。而具有内部链接性的实体则限制了它们的可见性，有助于将实现细节隐藏在文件内部，提高代码的封装性。\n2.4、作用域 在C语言中，作用域（scope）是指在程序中某个特定区域或上下文中可见和有效的标识符（变量、函数、类型等）的范围。\nC语言中存在以下几种作用域：\n块作用域（Block Scope）：块作用域指的是由花括号（{}）包围的代码块内部的范围。在块作用域中定义的标识符仅在该块内可见，在块外部不可访问。 1 2 3 4 5 6 7 8 9 10 11 void myFunction() { int x = 10; // 块作用域中定义的变量 // x 在此可见 { int y = 20; // 嵌套的块作用域中定义的变量 // x 和 y 在此可见 } // x 在此仍然可见，但 y 不可见 } 函数作用域（Function Scope）：函数作用域指的是函数内部定义的标识符的范围。在函数作用域中定义的标识符对于函数内的所有代码块都是可见的，但在函数外部不可访问。 1 2 3 4 5 6 7 8 int x = 10; // 全局变量 void myFunction() { int y = 20; // 函数作用域中定义的变量 // x 和 y 在此可见 } // x 在此仍然可见，但 y 不可见 文件作用域（File Scope）：文件作用域指的是在函数外部定义的标识符的范围。在文件作用域中定义的标识符对整个文件内的代码块都是可见的，可以被多个函数访问。 1 2 3 4 5 6 7 8 9 10 // 文件作用域中定义的全局变量 int x = 10; void myFunction1() { // x 在此可见 } void myFunction2() { // x 在此可见 } 作用域的概念对于正确的变量命名和避免命名冲突非常重要。通过将标识符限定在特定的作用域内，可以提高代码的可读性、维护性和可靠性。在C语言中，作用域由大括号和函数定义等控制结构来界定，并且作用域规则在编译时由编译器进行解析和处理。\n总结 refs 《The C programming language, second edition》 ","wordCount":"3280","inLanguage":"zh","datePublished":"2023-06-11T14:03:41+08:00","dateModified":"2023-06-11T14:03:41+08:00","author":{"@type":"Person","name":"陈十一"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://00001011b.github.io/posts/tech/%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/"},"publisher":{"@type":"Organization","name":"落魄山","logo":{"@type":"ImageObject","url":"https://00001011b.github.io/images/author.jpg"}}}</script><script src=/js/iconfont.js></script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://00001011b.github.io/ accesskey=h title="落魄山 (Alt + H)"><img src=https://00001011b.github.io/images/author.jpg alt=logo aria-label=logo height=35>落魄山</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://00001011b.github.io/tags/ title=🍥标签><span>🍥标签</span></a></li><li><a href=https://00001011b.github.io/archives/ title=🍣时间轴><span>🍣时间轴</span></a></li><li><a href=https://00001011b.github.io/about/ title=🍚关于><span>🍚关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>理解C语言变量</h1><div class=post-meta><svg class="icon" aria-hidden="true"><use xlink:href="#icon-guanyuwomen"/></svg>&nbsp;<span>陈十一</span> &nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-rili"/></svg>&nbsp;<span title='2023-06-11 14:03:41 +0800 +0800'>&nbsp;2023-06-11</span>&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-pinpaigushi"/></svg>&nbsp;3280字&nbsp;&nbsp;&nbsp;<svg class="icon" aria-hidden="true"><use xlink:href="#icon-shijian"/></svg>: 7分钟</div></header><div class=post-content><p>变量（value）是标识符（identifier）的一个子集。因此在讲变量之前，先要说一下标识符（identifier）。</p><h3 id=1标识符>1、标识符<a hidden class=anchor aria-hidden=true href=#1标识符>#</a></h3><p>标识符，本质上来讲，就是一个名字。通过这个名字，我们可以引用到（refers to） C 语言里的很多东西：</p><ul><li>函数（function）。</li><li>枚举、联合、结构体的标签（tags of enumeration, union and structure）。</li><li>联合、结构体的成员（members of union and structure）。</li><li>枚举常量（enumeration constant）。</li><li>用 typedef 创建的名字（typedef names）。</li><li>对象（object）。</li></ul><p>标志符与生俱来就有两个属性。我们思考一下，当我们写下一个标识符的时候，会面临两个问题的：</p><ol><li>这个标志符的可见性是？</li><li>如果我写了一个标识符：randomvalue，在别的模块里，别人也写了一样的标识符，那怎么办？</li></ol><p>这两个问题就延伸出两种极其重要的属性了。</p><blockquote><p>A name also has a scope, which is the region of the program in which it is known, and a linkage, which detemines whether the same name in another scope refers to the same object or function.</p></blockquote><p>即：一个名称（标识符）还具有作用域，即其所在的程序区域，在该区域内可以识别该名称，并且还具有链接性，决定了在另一个作用域中是否使用相同的名称引用相同的对象或函数。</p><h3 id=2变量>2、变量<a hidden class=anchor aria-hidden=true href=#2变量>#</a></h3><p>根据上一节我们知道，标识符具有两个属性。</p><p><strong>作用域</strong>： 指在程序中定义的变量、函数或其他命名实体的可见性和有效范围。它决定了在程序的哪些部分可以访问和使用这些实体。作用域规定了变量或函数的名称在程序中的可访问范围，并且可以帮助避免命名冲突。</p><p><strong>链接性</strong>：指在程序中不同作用域中同名实体之间的关联性和连接性。它确定了同名实体在不同作用域中是否引用相同的对象或函数。</p><p>变量是标识符的子集，因此也是天然继承了这两个属性的。除此之外，变量还有另外两个属性：<strong>存储类别（storage class）<strong>和</strong>类型（type）</strong>。</p><p>下面，我要对变量的这四种属性进行细说。</p><h4 id=21存储类别>2.1、存储类别<a hidden class=anchor aria-hidden=true href=#21存储类别>#</a></h4><p>在编程中，存储类别（storage class）是用于指定变量或函数的存储位置、生命周期和可见性的修饰符。</p><p>在C语言中有以下存储类别：</p><p>auto：默认的存储类别，用于指定局部变量的存储，表示变量在代码块中的自动创建和销毁。</p><p>register：用于请求将变量存储在寄存器中，以便快速访问。然而，这只是一个建议，编译器可以忽略它。</p><p>static：用于指定静态变量的存储，这些变量在整个程序执行期间都存在，不会随着作用域的进入和退出而创建或销毁。</p><p>extern：用于声明外部变量或函数，表示这些实体是在其他文件中定义的。</p><p>typedef：用于创建自定义的类型别名，不直接与存储相关，但在存储类别的讨论中常常提及。</p><h4 id=22类型>2.2、类型<a hidden class=anchor aria-hidden=true href=#22类型>#</a></h4><p>在C语言中，类型（type）是用来描述数据的性质、大小和操作方式的概念。每个变量、表达式和函数都有一个特定的类型，它决定了该实体能够存储的数据范围、内存占用以及可对其执行的操作。</p><p>C语言提供了多种基本类型和派生类型，包括但不限于以下几种：</p><ol><li><p>基本类型（Basic Types）：C语言提供了一些基本的数据类型，如整数类型（如<code>int</code>、<code>char</code>）、浮点数类型（如<code>float</code>、<code>double</code>）和布尔类型（<code>_Bool</code>）。这些类型用于存储基本的数据值。</p></li><li><p>数组类型（Array Types）：数组是一种由相同类型的元素组成的集合，可以通过下标访问和操作其中的元素。</p></li><li><p>结构体类型（Struct Types）：结构体是一种用户自定义的数据类型，它可以包含多个不同类型的成员变量。</p></li><li><p>枚举类型（Enum Types）：枚举类型是一种用户自定义的类型，用于定义一组相关的命名常量。</p></li><li><p>指针类型（Pointer Types）：指针是一种特殊的数据类型，它存储了其他类型数据对象的内存地址。</p></li><li><p>函数类型（Function Types）：函数也具有类型，它描述了函数的返回值类型和参数类型。</p></li></ol><p>类型在C语言中具有重要的作用，它们决定了数据的表示和操作方式。在编程过程中，正确的类型使用可以确保数据的正确性和一致性，同时提供了对数据进行有效操作和处理的工具。</p><p>例如，考虑以下代码片段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>3.14</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>c</span> <span class=o>=</span> <span class=sc>&#39;A&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上述代码中，变量 <code>x</code> 的类型为 <code>int</code>，可以存储整数值。变量 <code>y</code> 的类型为 <code>float</code>，可以存储浮点数值。变量 <code>c</code> 的类型为 <code>char</code>，可以存储单个字符。函数 <code>add</code> 的类型为返回值为 <code>int</code>，参数为两个 <code>int</code> 类型的函数。</p><p>理解C语言中的类型有助于正确声明和使用变量、函数和数据结构，并确保在操作数据时符合语言规范和预期行为。</p><h4 id=23链接性>2.3、链接性<a hidden class=anchor aria-hidden=true href=#23链接性>#</a></h4><p>在C语言中，链接性（linkage）指的是标识符（变量、函数、常量等）在不同编译单元（源文件）之间的关联性和连接性。它确定了同名标识符在不同编译单元中是否引用相同的对象或函数。</p><p>C语言中的链接性有以下几种类型：</p><ol><li>外部链接性（External Linkage）：具有外部链接性的标识符可以在不同的源文件之间共享和访问。它们在不同的编译单元中表示同一个实体。可以通过使用 <code>extern</code> 关键字来声明具有外部链接性的变量或函数。</li></ol><p>例子：</p><p>在源文件 A.c 中定义了一个具有外部链接性的全局变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// A.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>globalVar</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>在源文件 B.c 中使用了外部链接性的全局变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// B.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>int</span> <span class=n>globalVar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 在此可以使用 globalVar
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上述示例中，全局变量 <code>globalVar</code> 在 A.c 中定义，具有外部链接性，然后在 B.c 中使用 <code>extern</code> 关键字声明，并在函数 <code>myFunction</code> 中访问。通过外部链接性，B.c 可以访问并共享 A.c 中定义的 <code>globalVar</code>。</p><ol start=2><li>内部链接性（Internal Linkage）：具有内部链接性的标识符只能在定义它们的单个源文件中访问。它们在文件内部是可见的，但无法跨源文件共享。</li></ol><p>例子：</p><p>在源文件 A.c 中定义了一个具有内部链接性的静态变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// A.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=n>staticVar</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>在源文件 B.c 中无法访问具有内部链接性的静态变量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// B.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>int</span> <span class=n>staticVar</span><span class=p>;</span> <span class=c1>// 错误：无法访问具有内部链接性的静态变量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 无法访问 staticVar
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在上述示例中，静态变量 <code>staticVar</code> 在 A.c 中定义，具有内部链接性，只能在 A.c 内部访问。在 B.c 中使用 <code>extern</code> 关键字尝试访问 <code>staticVar</code> 会导致编译错误。</p><p>需要注意的是，具有外部链接性和内部链接性的标识符可以是全局变量、静态变量或函数。它们的链接性是由标识符的声明或定义方式决定的。</p><p>理解链接性的概念有助于编写模块化的代码，并控制标识符的可见性和共享性。它可以用于限制变量和函数的作用范围，避免命名冲突，并支持多文件的程序开发。</p><p>链接性的概念在多文件的程序开发中尤为重要。通过定义具有外部链接性的变量或函数，可以在多个文件中共享它们，从而促进代码的模块化和重用。而具有内部链接性的实体则限制了它们的可见性，有助于将实现细节隐藏在文件内部，提高代码的封装性。</p><h4 id=24作用域>2.4、作用域<a hidden class=anchor aria-hidden=true href=#24作用域>#</a></h4><p>在C语言中，作用域（scope）是指在程序中某个特定区域或上下文中可见和有效的标识符（变量、函数、类型等）的范围。</p><p>C语言中存在以下几种作用域：</p><ol><li>块作用域（Block Scope）：块作用域指的是由花括号（{}）包围的代码块内部的范围。在块作用域中定义的标识符仅在该块内可见，在块外部不可访问。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// 块作用域中定义的变量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// x 在此可见
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 嵌套的块作用域中定义的变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// x 和 y 在此可见
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// x 在此仍然可见，但 y 不可见
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>函数作用域（Function Scope）：函数作用域指的是函数内部定义的标识符的范围。在函数作用域中定义的标识符对于函数内的所有代码块都是可见的，但在函数外部不可访问。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// 全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span> <span class=c1>// 函数作用域中定义的变量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// x 和 y 在此可见
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// x 在此仍然可见，但 y 不可见
</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>文件作用域（File Scope）：文件作用域指的是在函数外部定义的标识符的范围。在文件作用域中定义的标识符对整个文件内的代码块都是可见的，可以被多个函数访问。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 文件作用域中定义的全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x 在此可见
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>myFunction2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x 在此可见
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>作用域的概念对于正确的变量命名和避免命名冲突非常重要。通过将标识符限定在特定的作用域内，可以提高代码的可读性、维护性和可靠性。在C语言中，作用域由大括号和函数定义等控制结构来界定，并且作用域规则在编译时由编译器进行解析和处理。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p><img loading=lazy src=/images/Identifier.png alt></p><h3 id=refs>refs<a hidden class=anchor aria-hidden=true href=#refs>#</a></h3><ol><li><a href=https://book.douban.com/subject/1882483/>《The C programming language, second edition》</a></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://00001011b.github.io/posts/tech/%E4%BB%8E%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E5%8E%BB%E7%90%86%E8%A7%A3c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/><span class=title>« 上一页</span><br><span>从底层逻辑去理解C语言的枚举类型</span></a>
<a class=next href=https://00001011b.github.io/posts/plans/2023%E5%B9%B4%E8%AE%A1%E5%88%92/><span class=title>下一页 »</span><br><span>2023年计划</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://00001011b.github.io/>落魄山</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>